package com.hers.robinet.tfe.descriptor;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

import com.hers.robinet.tfe.mananger.DbManager;
import com.hers.robinet.tfe.mananger.SchemaDB;

/**
 * Represent a attribute.
 * Supported annotation:
 * 	@column name, nullable, unique
 *  @id
 *  @GeneretedValue (on Integer, unique for the table. Id can be ommited for this attribute)
 *  @OneToOne, @OneToMany, @ManyToOne, @ManyToMany
 *  @Transient
 */
public abstract class RelationDescriptor {

	protected ArrayList<TypeDescriptor> typeStruct = new ArrayList<TypeDescriptor>();
	protected boolean isAutoGenerated = false;
	protected boolean isId = false;
	protected boolean isnullable = false;
	protected boolean isUnique = false;
	protected boolean isAbstract = false;
	protected int relationType = DbManager.noRelation;
	
	
	public static RelationDescriptor getAttribute(Field attribute, ClassDescriptor tableClass, SchemaDB schema)
	{
		int relationType = DbManager.noRelation;
		for (Annotation annotation : attribute.getAnnotations()){
			if (annotation instanceof javax.persistence.Transient)
			{
				return null;
			}
			
			if (!DbManager.isPrimaryType(attribute.getType()))
			{
				if (annotation instanceof javax.persistence.OneToOne){
					relationType = DbManager.OneToOne;
				}
				else if (annotation instanceof javax.persistence.ManyToOne){
					relationType = DbManager.ManyToOne;
				}
				else if (annotation instanceof javax.persistence.OneToMany){
					relationType = DbManager.OneToMany;
				}
				else if (annotation instanceof javax.persistence.ManyToMany){
					relationType = DbManager.ManyToMany;
				}
				else{
					throw new ModelRuntimeException("A class which is not a primitive type(cf:doc) should have a relation");
				}
			}
		}
		
		if(relationType == DbManager.noRelation){
			return new AttributeDescriptor(attribute);
		}
		else if(relationType == DbManager.OneToOne){
			return new RelationOneToOneDescriptor(attribute, schema);
		}
		else if(relationType == DbManager.ManyToOne){
			return new RelationManyToOneDescriptor(attribute, schema);
		}
		else if(relationType == DbManager.OneToMany)
		{
			return new RelationOneToManyDescriptor(attribute, schema);
		}
		else if(relationType == DbManager.ManyToMany){
			return new RelationManyToManyDescriptor(attribute, schema, tableClass);
		}
		return null;
	}
	
	
	
	
	public ArrayList<TypeDescriptor> getTypeStruct() {
		return typeStruct;
	}

	public int getRelationType() {
		return relationType;
	}
	
	public boolean isAutoGenerated() {
		return isAutoGenerated;
	}

	public boolean isId() {
		return isId;
	}

	public boolean isIsnullable() {
		return isnullable;
	}

	public boolean isUnique() {
		return isUnique;
	}
	
	public boolean isAbstract()
	{
		return isAbstract;
	}
	
	public ClassDescriptor getReferencedTable()
	{
		throw new UnsupportedOperationException();
	}
	
	public static class JpaRelationIterator implements Iterator<TypeDescriptor>
	{
		private ArrayList<RelationDescriptor> el;
		private int i = 0;
		private int innerI = -1;
		
		public JpaRelationIterator(ArrayList<RelationDescriptor> el)
		{
			this.el = el;
		}
		
		public boolean hasNext() {
			
			if (i<el.size())
			{
				int tempI = i;
				int tempInnerI = innerI;
				
				++tempInnerI;
				while(tempI<el.size() && tempInnerI >= el.get(tempI).getTypeStruct().size())
				{
					tempInnerI = 0;
					++tempI;
				}
								
				if(tempI<el.size() && el.get(tempI).getTypeStruct().size()>tempInnerI)
				{
					return true;
				}
				else{
					return false;
				}
			}
			return false;
		}
		
		public RelationDescriptor getCurrentRelation()
		{
			return el.get(i);
		}

		public TypeDescriptor next() {
			if (!hasNext()) throw new NoSuchElementException();
			++innerI;
			while(i<el.size() && innerI >= el.get(i).getTypeStruct().size())
			{
				innerI = 0;
				++i;
			}
			System.out.println("i:"+i +" innerI:"+innerI);
			return el.get(i).getTypeStruct().get(innerI);
		}	
	}
}
